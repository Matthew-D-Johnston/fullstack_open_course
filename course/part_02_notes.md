## Fullstack Open Course — Part 2

### a) Rendering a collection, modules

#### Rendering Collections

Let's start with the following example (the file _App.js_):

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        <li>{notes[0].content}</li>
        <li>{notes[1].content}</li>
        <li>{notes[2].content}</li>
      </ul>
    </div>
  )
}

export default App
```

The file _index.js_ looks like:

```javascript
import React from 'react'
import ReactDOM from 'react-dom/client'

import App from './App'

const notes = [
  {
    id: 1,
    content: 'HTML is easy',
    date: '2019-05-30T17:30:31.098Z',
    important: true
  },
  {
    id: 2,
    content: 'Browser can execute only JavaScript',
    date: '2019-05-30T18:39:34.091Z',
    important: false
  },
  {
    id: 3,
    content: 'GET and POST are the most important methods of HTTP protocol',
    date: '2019-05-30T19:20:14.298Z',
    important: true
  }
]

ReactDOM.createRoot(document.getElementById('root')).render(
  <App notes={notes} />
)
```

The example above works due to the fact that there are exactly three notes in the array.  

A single note is rendered by accessing the objects in the array by referring to a hard-coded index number:

```javascript
<li>{notes[1].content}</li>
```

This is, of course, not practical. We can improve on this by generating React elements from the array objects using the map function.  

```javascript
notes.map(note => <li>{note.content}</li>);
```

The result is an array of _li_ elements.

```javascript
[
  <li>HTML is easy</li>,
  <li>Browser can execute only JavaScript</li>,
  <li>GET and POST are the most important methods of HTTP protocol</li>,
]
```

Which can then be placed inside _ul_ tags:

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

#### Key-attribute

Even though the application seems to be working, there is a nasty warning in the console:

```
Warning: Each child in a list should have a unique "key" prop.

Check the render method of `App`. See https://reactjs.org/link/warning-keys for more information.
    at li
    at App (http://localhost:3000/static/js/bundle.js:23:5)
```

As the error message suggests; the list items, i.e. the elements generated by the `map` method, must each have a unique key value: an attribute called _key_.  

Let's add the keys:

```javascript
const App = (props) => {
  const { notes } = props

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <li key={note.id}>
            {note.content}
          </li>
        )}
      </ul>
    </div>
  )
}
```

And the error message disappears.  

React uses the key attributes of objects in an array to determine how to update the view generated by a component when the component is re-rendered.

#### Refactoring Modules

We'll separate displaying a single note into its own component _Note_:

```javascript
const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

const App = ({ notes }) => {
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
    </div>
  )
}
```

Note that the _key_ attribute must now be defined for the _Note_ components, and not for the _li_ tags like before.  

A whole React application can be written in a single file. Although that is, of course, not very practical. Common practice is to declare each component in their own file as an _ES6-module_.  

We have been using modules the whole time. The first few lines of the file _index.js_:

```javascript
import React from 'react'
import ReactDOM from 'react-dom/client'

import App from './App'
```

import three modules, enabling them to be used in that file. The module _React_ is placed into the variable `React`, the module _react-dom_ into the variable `ReactDOM`, and the module that defines the main component of the app is placed into the variable `App`

Let's move our _Note_ component into its own module.  

In smaller applications, components are usually placed in a directory called _components_, which is in turn placed within the _src_ directory. The convention is to name the file after the component.  

Now, we'll create a directory called _components_ for our application and place a file named _Note.js_ inside. The contents of the Note.js file are as follows:

```javascript
const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

export default Note
```

The last line of the module exports the declared module, the variable _Note_.  

Now the file that is using the component—_App.js_—can import the module:  

```javascript
import Note from './components/Note'

const App = ({ notes }) => {
  // ...
}
```

The component exported by the module is now available for use in the variable _Note_, just as it was earlier.  

Note that when importing our own components, their location must be given _in relation to the importing file_:

```
'./components/Note'
```

The period—.—in the beginning refers to the current directory, so the module's location is a file called _Note.js_ in the _components_ sub-directory of the current directory. The filename extension `.js` can be omitted.  

---

### b) Forms

Let's continue expanding our application by allowing users to add new notes.  

In order to get our page to update when new notes are added it's best to store the notes in the _App_ component's state. Let's import the `useState` function and use it to define a piece of state that gets initialized with the initial notes array passed in the props.  

```javascript
import { useState } from 'react'
import Note from './components/Note'

const App = (props) => {
  const [notes, setNotes] = useState(props.notes)

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
    </div>
  )
}

export default App
```

Next, let's add an HTML form to the component that will be used for adding new notes.

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)

  const addNote = (event) => {
    event.preventDefault()
    console.log('button clicked', event.target)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

We have added the `addNote` function as an event handler to the form element that will be called when the form is submitted, by clicking the submit button.  

How do we access the data contained in the form's _input_ element?  

#### Controlled component

There are many ways to accomplish this; the first method we will take a look at is through the use of so-called controlled components.  

Let's add a new piece of state called `newNote` for storing the user-submitted input and let's set it as the _input_ element's _value_ attribute:

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 

  const addNote = (event) => {
    event.preventDefault()
    console.log('button clicked', event.target)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input value={newNote} />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

The placeholder text stored as the initial value of the `newNote` state appears in the _input_ element, but the input text can't be edited. The console displays a warning that gives us a clue as to what might be wrong:

![fullstack content](https://fullstackopen.com/static/2905b1f4edfe786a70566fe4a7a3a0e9/5a190/7e.png)

Since we assigned a piece of the _App_ component's state as the _value_ attribute of the input element, the _App_ component now controls the behaviour of the input element.  

In order to enable editing of the input element, we have to register an _event handler_ that synchronizes the changes made to the input with the component's state:  

```javascript
const App = (props) => {
  const [notes, setNotes] = useState(props.notes)
  const [newNote, setNewNote] = useState(
    'a new note...'
  ) 

  // ...

  const handleNoteChange = (event) => {
    console.log(event.target.value)
    setNewNote(event.target.value)
  }

  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
      <form onSubmit={addNote}>
        <input
          value={newNote}
          onChange={handleNoteChange}
        />
        <button type="submit">save</button>
      </form>   
    </div>
  )
}
```

We have now registered an event handler to the _onChange_ attribute of the form's _input_ element:

```javascript
<input
	value={newNote}
	onChange={handleNoteChange}
/>
```

The event handler is called every time _a change occurs in the input element_. The event handler function receives the event object as its `event` parameter:  

```javascript
const handleNoteChange = (event) => {
  console.log(event.target.value)
  setNewNote(event.target.value)
}
```

The `target` property of the event object now corresponds to the controlled _input_ element, and `event.target.value` refers to the input value of that element.  

Note that we did not need to call the `event.preventDefault()` method lik we did in the _onSubmit_ event handler. This is because there is no default action that occurs on an input change, unlike on a form submission.  

Now the _App_ component's `newNote` state reflects the current value of the input, which means that we can complete the `addNote` function for creating new notes:

```javascript
const addNote = (event) => {
  event.preventDefault()
  const noteObject = {
    content: newNote,
    date: new Date().toISOString(),
    important: Math.random() < 0.5,
    id: notes.length + 1,
  }

  setNotes(notes.concat(noteObject))
  setNewNote('')
}
```

First, we create a new object for the note called `noteObject` that will receive its content from the component's `newNote` state. The unique identifier _id_ is generated based on the total number of notes. This method works for our application since notes are never deleted. With the help of the `Math.random()` function, our note has a 50% chance of being marked as important.  

#### Filtering Displayed Elements

